 \hoffset1cm % przesunięcie poziome (przykładowo) o 1cm przeznaczone na oprawę
\documentclass[11pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts}
%\usepackage{txfonts}
\usepackage{polski}
 
 \usepackage{amsmath}
 \usepackage{amssymb}
 \usepackage{indentfirst}
 \usepackage{listings}
 \usepackage{}
% \usepackage{natbib}
 \usepackage[backend=biber, bibencoding=utf8, style=ieee, isbn=false, doi=false, sorting=anyvt]{biblatex}
%  \bibliographystyle{acm}
 \addbibresource{library.bib}
 \DeclareUnicodeCharacter{229}{ę}
 \DeclareUnicodeCharacter{327}{}
 
 \pagestyle{headings}
 
\renewcommand{\chaptername}{Rozdział}
\renewcommand{\contentsname}{Spis treści}
\renewcommand{\figurename}{Rys.}
\renewcommand{\tablename}{Tab.}
\renewcommand{\listfigurename}{Spis rysunków}
\renewcommand{\listtablename}{Spis tabel}
\renewcommand{\bibname}{Bibliografia}

 \begin{document}

 \begin{titlepage}
 \center{\large\scshape Politechnika Krakowska \\
         \normalsize im. Tadeusza Kościuszki}
 \center{\scshape Wydział Inżynierii Elektrycznej i Komputerowej\\
         Kierunek Informatyka}
 \vspace{0.1\textheight}
 \center{\scshape Michał Patyk}
 \bigskip
 \center{\LARGE\bfseries Sterownik pieca kominkowego, w oparciu o mikrokontroler (lub platformę komputerową), zgodny ze szkicem specyfikacji Web Thing API}
 \center{(praca inżynierska)}
 \vspace{0.3\textheight}
 \par
 \rightline{Promotor: Dr Radosław Czarnecki}

 \vspace{0.1\textheight}
 \center{Kraków 2020}
 \end{titlepage}


 \tableofcontents


 \chapter{Wstęp}
% \addcontentsline{toc}{chapter}{Wstęp}
 \section{Rys historyczny - ujęcie problemowe}
 \subsection{Problem ogrzewania}
 Problem ogrzewania pomieszczeń towarzyszy człowiekowi od zarania dziejów \cite{Hoppe2018}. Zwykle był to proces wymagający ciągłego nadzoru. Potrzeba automatyzacji wydaje się naturalną konsekwencją zmiany trybu życia człowieka. Wraz z pojawieniem się nowoczesnych kotłów powstały pierwsze mechanizmy kontrolujące pracę urządzenia bez nieustannej konieczności doglądania go.
 Pojawienie się sterowników cyfrowych zaoferowało zupełnie nowe możliwości, takie jak:
  \begin{enumerate}
 \item[•] większą efektywność pracy systemu grzewczego
 \item[•] zmniejszenie emitowanych zanieczyszczeń
 \item[•] wzrost komfortu użytkowania
 \item[•] poprawę bezpieczeństwa
 \item[•] w nowszych modelach - zdalne sterowanie
  \end{enumerate}
 Sterowniki cyfrowe wydają się również odpowiedzią na coraz bardziej dostrzegany problem odpowiedzialnego wykorzystywania zasobów naturalnych \cite{Mazurek2018}\cite{Mazurek2018a}, gdyż za ich pomocą do zapewnienia komfortu termicznego pomieszczeń potrzebna jest znacznie mniejsza ilość paliwa. Stanowią one również propozycję rozwiązania problemu ubóstwa energetycznego.
 \subsection{Integracja urządzeń}
 Sukces internetu spowodował zainteresowanie naukowców podłączeniem do sieci fizycznych urządzeń.
 Termin internet rzeczy powstał w 1999 roku wymyślony przez Kevina Ashtona \cite{Ashton2009} jednak jego popularność rozpoczęła się dopiero kilka lat temu, a w tej chwili przechodzi okres stagnacji.
 Możemy wyróżnić wiele przypadków zastosowania internetu rzeczy:
 \begin{enumerate}
 \item[•] bezprzewodowe sieci czujników i pomiary rozproszone
 \item[•] urządzenia ubieralne i pomiary osobiste
 \item[•] inteligentne domy i budynki
 \item[•] inteligentne miasta i sieci energetyczne
 \item[•] inteligentna produkcja przemysłowa
 \item[•] inteligentna logistyka i łańcuchy dostaw.
\end{enumerate}
 Przyjęte przez niewielkie grupy korporacji standardy internetu rzeczy podlegają ciągłej ewolucji spowodowanej rozwojem technologicznym, a zamknięte protokoły prowadzą do sytuacji, w której zmiana dostawcy rozwiązań jest mocno utrudniona i może powodować konieczność zmiany sprzętu. Standardy webowe, takie jak HTTP, JSON i Web Socket, zawdzięczają swoją popularność otwartości oraz brakowi opłat. Ich zastosowanie do integracji urządzeń i aplikacji w znacznym stopniu może ułatwić wchodzenie w interakcję z rzeczami.
 
 \section{Stan aktualnej wiedzy}
 \subsection{Sterowniki}
 Obecnie na rynku dostępny jest szeroki wachlarz rozwiązań, od prostych jednokomponentowych do bardziej zaawansowanych, złożonych. Począwszy od regulatorów pokojowych, które jedynie włączają ogrzewanie kiedy temperatura pomieszczenia obniży się poniżej nastawionej wartości, poprzez rozbudowane, umożliwiające programowanie temperatury zarówno w ciągu doby (niższa w nocy, wyższa po południu), jak i w wybrane dni tygodnia. Skończywszy na automatyce pogodowej, która dzięki wykorzystaniu czujnika zewnętrznego, umieszczonego na ścianie domu, przewiduje zwiększone zapotrzebowanie na ciepło i wcześniej dostosowuje moc kotła.
 Coraz więcej dostępnych na rynku sterowników umożliwia zdalne nastawienie temperatury. W znakomitej większości standard komunikacji tych rozwiązań jest zamknięty, co utrudnia współpracę  z innymi inteligentnymi urządzeniami.
 \subsection{Internet rzeczy i WWW rzeczy}
 W Europie Wschodniej występuje wciąż mała na tle konkurencji liczba firm oferujących rozwiązania IoT.
  \begin{figure}[ht]
\centering
\includegraphics[width=0.8 \textwidth]{fig/liczba_firm_rozwiazania_iot.png}
\caption{Liczba firm oferujących rozwiązania IoT na poszczególnych rynkach. (źródło: \cite{gov2019})}
\label{fig:firmy}
\end{figure}
 Wzmożony rozwój tematu WWW rzeczy zapoczątkowany został przez pracę doktorską Dominique'a Guinarda \cite{Guinard2011}, a pogłębiło go wydanie książki \cite{Guinard2017} podsumowującej dotychczasowe prace autora w tym temacie \cite{Guinard2009} \cite{Guinard2010} \cite{Guinard2010a} \cite{Guinard2011} \cite{Guinard2011a}.
 W 2014 roku przy World Wide Web Consortium, grupie zajmującej się ustanawianiem standardów pisania i przesyłu stron WWW, powstała Web of Things Interest Group \cite{wotig2014} która pracuje nad dokumentami opisującymi Rzeczy Webowe \cite{thingdescription} oraz Architekturę \cite{wotarchitecture}.
 W 2017 roku do projektowania Web of Things przyłącza się fundacja Mozilli \cite{mozilla2017} tworząc i rozbudowując projekt WebThings Gateway. Przyciągnął on liczną i aktywną społeczność znacząco rozwijającą przedsięwzięcie.  W następnych latach przybywa kolejnych prac naukowych na temat Web of Things \cite{IEEE2018} \cite{Raggett2018} \cite{Korkan2019}.
   \begin{figure}[ht]
\centering
\includegraphics[width=0.8 \textwidth]{fig/contributions.png}
\caption{Liczba przesłanych fragmentów kodu przez społecznośc WebThings Gateway. (zródło: \cite{gatewaycommits2020})}
\label{fig:firmy}
\end{figure}

 \section{Innowacyjność projektu na tle współczesnych rozwiązań}
 W odróżnieniu od szeroko stosowanych rozwiązań mój projekt zakłada użycie specyfikacji Web Thing API \cite{WebThing2020}, która pozwala na ujednolicenie dostępu do inteligentnych rzeczy za pomocą dodatkowej warstwy abstrakcji. Oznacza to, że system kreuje przestrzeń kooperacji urządzeń. Możliwe interakcje wpływają pozytywnie na koherentność systemu.
 
 \section{Motywacja}
Pomysł na pracę zrodził się z potrzeby zmniejszenia ilości czasu oraz poświęcanej uwagi potrzebnych do obsługi pieca kominkowego, pracującego jako główne źródło ciepła w domu jednorodzinnym. Ponadto niekomfortowym ograniczeniem dotychczas stosowanych rozwiązań jest zmuszanie klienta do użytkowania produktów pochodzących od tego samego producenta, co w znaczącym stopniu ogranicza możliwość wyboru preferowanego sprzętu.

 \chapter{Cele pracy, zakres pracy, założenia}

 \section{Cele pracy}
 Celem niniejszej pracy jest \textbf{opracowanie koncepcji sterownika pieca kominkowego} zgodnego ze szkicem specyfikacji Web Thing API.
 +
 \section{Zakres pracy}
 Zakres pracy obejmuje:
 \begin{enumerate}
 \item przegląd istniejących rozwiązań - zarówno sprzętowych jak i programowych;
 \item opracowanie koncepcji;
 \item wybór podzespołów;
 \item wykonanie prototypu na płytce stykowej;
 \item stworzenie oprogramowania;
 \item przetestowanie oprogramowania; 
 \item wykonanie prototypu na płytce uniwersalnej;
 \item wykonanie obudowy;
 \item zintegrowanie z Mozilla Gateway
 \end{enumerate}
 
 \section{Założenia i wymagania}
 Projekt sterownika zostanie wykonany zgodnie z dobrymi praktykami dotyczącymi programowania zawartymi między innymi w pracach Grębosza \cite{Grebosz2018} i Francuza \cite{Francuz2015}. Część sprzętowa projektu zostanie opracowana na podstawie książek Monka \cite{Monk2014} \cite{Monk2014a} \cite{Monk2018}, Kurczyka \cite{Kurczyk2019}, Huanga \cite{Huang2018} i Wallace'a \cite{Wallace2019} oraz norm Polskiego Komitetu Normalizacyjnego \cite{PKN1999} \cite{PKN2000}.
 
 \subsection{Wykorzystane narzędzia}
 \begin{enumerate}
 \item[•] środowisko programistyczne CLion
 \item[•] język programowania C/C++
 \item[•] ekosystem PlatformIO
 \item[•] platforma monitoringu i kontroli urządzeń WebThing Mozilla
 \end{enumerate}
 
 \subsection{Możliwości}
 \begin{enumerate}
 \item[•] monitorowanie pracy pieca kominkowego
 \item[•] zdalne zadawanie temperatur
 \item[•] informowanie o zdarzeniach
 \end{enumerate}
 
 \subsection{Wymagania}
 \begin{enumerate}
 \item[•] zgodność z Web Thing API
 \item[•] możliwość rozbudowy o dodatkowe czujniki i elementy wykonawcze
 \item[•] przywracanie nastaw po utracie zasilania
 \item[•] minimalizacja otwarcia przepustnicy w przypadku zaniku napięcia
 \item[•] sygnalizacja uszkodzenia czujnika temperatury
 \item[•] regulowana jasność wyświetlacza - zwiększana na czas zmiany ustawień
 \item[•] sygnalizator dźwiękowy który informuje gdy temperatura wzrośnie do niebezpiecznego poziomu
 \end{enumerate}
 
 \section{Efekt końcowy}
 Planowanym efektem końcowym pracy będzie stworzenie sterownika pieca kominkowego, pozwalającego na bezobsługową pracę paleniska pomiędzy momentami uzupełniania paliwa.

 Element wyróżniający wykonany sterownik stanowi wykorzystanie Web Thing REST API, który pozwala na wykorzystanie sieci jako zunifikowanej warstwy abstrakcji dla zdecentralizowanego internetu rzeczy.
 
 Rysunek~\ref{fig:wizja} na stronie~\pageref{fig:wizja} przedstawia wizję struktury elementów sterownika.
 \begin{figure}[ht]
\centering
\includegraphics[width=0.8 \textwidth]{fig/fritzing_bredboard_v1.png}
\caption{Wizja elementów sterownika. (opracowanie własne)}
\label{fig:wizja}
\end{figure}
 
 \section{Dalsze kierunki rozwoju}
 W tej części zostaną opisane możliwe kierunki rozwoju sterownika.
 \subsection{Integracja z innymi urządzeniami}
 Wykorzystanie WebThing API umożliwi w przyszłości łatwą integrację sterownika z dodatkowymi urządzeniami, takimi jak:
 \begin{enumerate}
 \item[•] czujnik pogodowy
 \item[•] systemem odzyskiwania ciepła ze spalin
 \item[•] inne źródła ciepła
 \end{enumerate}
 \subsection{Zmiany w oprogramowaniu sterownika}
 Oprogramowanie sterownika może zostać rozbudowane o przykładowe komponenty:
 \begin{enumerate}
 \item[•] dodatkowe opcje konfiguracyjne
 \item[•] programowanie czasowe
 \item[•] zabezpieczenie hasłem
 \item[•] dodatkowe tryby pracy pieca
 \end{enumerate}
 Możliwą do wprowadzenia zmianą może być też zastąpienie frameworka Arduino, bardziej profesjonalnym Espressif IoT Development Framework, który lepiej współpracuje z mikrokontrolerem ESP32.
 \subsection{Zmiany sprzętowe}
 Proponowanymi zmianami w obrębie sprzętowym są:
 \begin{enumerate}
 \item[•] zaprojektowanie i wykonanie płytki drukowanej
 \item[•] zaprojektowanie i wykonanie dedykowanej obudowy, np.: w technologi druku 3D
 \end{enumerate}
 

 \chapter{Charakterystyka metod obsługi pieca} 
 Obsługa w pełni manualna wymaga stałego nadzoru nad przebiegiem spalania. Jest bardzo absorbująca. Łatwo prowadzi do przekroczenia pożądanych temperatur. Pogarsza efektywność procesu spalania, co prowadzi do obniżenia ogólnej sprawności kotła, większego zapotrzebowania na opał, a w konsekwencji znacznie wyższych kosztów ogrzewania.
 
 Obsługa półautomatyczna pozwala na samodzielną pracę urządzenia pomiędzy momentami dokładania paliwa. Można wyróżnić dwie jej odsłony. Mechaniczna, w której głowica termostatyczna połączona jest z mechanizmem dźwigni. Na jej ramieniu znajduje się łańcuszek lub linka. Zaletą jest niski koszt. Elektroniczna, gdzie stosuje się sterownik pokojowy z serwomechanizmem. Koszt tego rozwiązania jest umiarkowany oraz zapewnia szerokie możliwości regulacji, umożliwiając dokonywanie nastaw lokalnie lub zdalnie. 
 
 Najdroższe jak i najbardziej autonomiczne rozwiązanie stanowi obsługa automatyczna, w której kocioł z podajnikiem paliwa pracuje samodzielnie do kilku dni.
 
 
 \chapter{Przegląd istniejących rozwiązań} 
 \section{Standardy integracji inteligentnych urządzeń}
 W przypadku internetu rzeczy producenci nie zwracali uwagi na stworzenie otwartych systemów komunikujących się ze sobą urządzeń. Szczególnie ograniczone były działania  podejmowane dla umożliwienia doraźnego współdziałania elementów składających się na internet rzeczy. Pomimo, że organizacje standaryzacyjne zaproponowały wiele protokołów, żaden z tych standardów nie zdobył na tyle dużej popularności by zdominować pozostałe rozwiązania. Coraz więcej urządzeń podłączanych do internetu udostępnia API, jednak każdy z nich został zaimplementowany z wykorzystaniem innych protokołów i używa innego modelu danych. Zamiast proponować kompletnie nowe normy komunikacyjne, Web of Things wykorzystuje istniejące, dobrze znane standardy webowe.
  
 \section{Sterowniki kominkowe}
 Na polskim rynku istnieje szeroka gama rozwiązań przeznaczonych dla kotłów na paliwo stałe, jednak stosunkowo niewielką ilość sterowników przeznaczono dla kominków. Istnieją wyłącznie modele z dodatkową przepustnicą, co ogranicza możliwość regulacji dopływu powietrza pierwotnego i wtórnego.
 \subsection{TECH STEROWNIKI}
 Firma TECH ma w swojej aktualnej ofercie \cite{Tech} trzy sterowniki do kominków. Dwa z nich są do kominków z płaszczem wodnym. Trzeci \cite{TechSterownik} przeznaczony jest do kominków z dystrybucją gorącego powietrza i mógłby zostać zastosowany przy piecu kominkowym. Czujnik mierzy temperaturę spalin w kominie.
 Aby mieć możliwość zdalnego dostępu do sterownika należy skorzystać z jednego z dwóch dodatkowych modułów komunikacyjnych - GSM lub Ethernet. Dostęp jest możliwy jedynie przez stronę producenta lub aplikację mobilną, brak publicznego API.
 Sam moduł Ethernet kosztuje około 500zł \cite{TechEthernetCena}.
 \subsection{EUROSTER}
 Firma EUROSTER ma w swojej aktualnej ofercie \cite{Euroster} tylko jeden sterownik do kominków. Jest on \cite{EurosterSterownik} przeznaczony do współpracy z kominkiem z płaszczem wodnym, więc nie może być zastosowany do pieca kominkowego, gdyż czujnik mierzy temperaturę wody obiegowej, która nie występuje w piecu kominkowym. Sterownik nie posiada możliwości zdalnego dostępu.
 Cena samego sterownika to około 300zł \cite{EurosterSterownikCena}. Dodatkowo należy zakupić przepustnicę.
 \subsection{Kratki}
 Firma Kratki ma w swoje ofercie \cite{Kratki} jeden sterownik do kominków występujący w kilku wersjach różniących się obudową i wielkością dołączonej do zestawu przepustnicy.
 Jest on przeznaczony do współpracy z kominkami każdego rodzaju, dlatego może zostać zastosowany do pieca kominkowego. Czujnik mierzy temperaturę w pobliżu paleniska. Sterownik nie posiada możliwości zdalnego dostępu. 
 Cena samego sterownika to około 400zł \cite{KratkiSterownik}.
  \subsection{Podsumowanie}
  Tylko jeden z wymienionych producentów pozwala na zdalny dostęp do sterownika, jednak jest on wyłącznie możliwy za pośrednictwem serwerów producenta. Brak publicznego API. Cena tego rozwiązania jest wysoka.
  Tylko jeden z wymienionych sterowników posiada czujnik pozwalający na mierzenie temperatury spalin.
  
  
 \chapter{Opracowanie koncepcji budowy sterownika pieca kominkowego}
 Projektowanie koncepcji sterownika pieca kominkowego rozpocząłem od skompletowania minimalnej wersji, na którą składały się: mikrokontroler, serwomechanizm oraz termopara. Do regulacji pracy pieca kominkowego jest potrzebne urządzenie potrafiące zmieniać położenie przepustnicy dolotu powietrza do komory spalania. Najbardziej optymalnym wyborem okazał się prosty serwomechanizm, którego dodatkową zaletą okazała się przystępna cena. Stopień otwarcia przepustnicy dobierany jest na podstawie temperatury spalin w kominie, mierzonej przez termoparę.
 Dodatkowymi elementami uzupełniającymi koncepcję są:
 \begin{enumerate}
 \item[•] termometr, mierzący temperaturę w pomieszczeniu, umożliwiający dobór mocy pieca w stosunku do zapotrzebowania na ciepło
 \item[•] wyświetlacz przekazujący informacje użytkownikowi
 \item[•] czujnik otwarcia drzwi paleniska umożliwiający zmianę parametry pracy po dołożeniu drewna
 \item[•] zdalny dostęp do sterownika w celu ułatwienia obsługi
 \item[•] moduł Ethernet pozwalający na usunięcie niepotrzebnego ruchu WiFi
 \item[•] zapasowe źródło zasilania, pozwalające na kontrolę pracy pieca w razie zaniku napięcia w sieci
 \item[•] przyciski na sterowniku do zmiany podstawowych parametrów
 \end{enumerate}  
 
  
 \chapter{Wybór podzespołów sterownika pieca kominkowego}
 \section{Mikrokontroler lub platforma komputerowa}
 Rozważanymi kandydatami na serce sterownika były:
 \begin{enumerate}
 \item platformy komputerowe:
 \begin{enumerate}
 \item[•] RaspberryPi
 \item[•] OrangePi
 \end{enumerate}
\item mikrokontrolery:
 \begin{enumerate}
 \item[•] Seria Arduino
 \item[•] STM32F103C8T6
 \item[•] ESP8266
 \item[•] ESP32
 \end{enumerate}
 \end{enumerate}
 Ze względu na koszt jak i rozdzielenie odpowiedzialności zdecydowałem się na wybór mikrokontrolera ESP32. Jest to układ System on Chip będący następcą ESP8266. Posiada on dwa rdzenie, moduł komunikacji WiFi oraz bluetooth. Wyróżnia go energooszczędność. Dużą zaletą jest stosunkowo niska cena (w Chinach około 25zł). Gotowa płytka deweloperska pozwala na wygodne prototypownie.
 
 \section{Wyświetlacz}
 Aby sterownik sprostał potrzebom użytkowników o pogorszonym wzroku, wyświetlacz powinien być duży i kontrastowy.
 Ze względu na to, że wszystkie parametry będą dostępne przez stronę internetową, wybrany został wyświetlacz LCD 2x16, który pozwoli na prezentowanie tylko kilku z nich w jednej chwili.
 
 \section{Termometr}
 Wybrany układ termometru DHT22 pozwala na pomiar temperatury i wilgotności, jednocześnie zapewniając dobrą precyzję odczytów. Dodatkowo wybrałem prosty moduł termometru Dallas DS18B20, który pozwala na pomiar temperatury wewnątrz sterownika.
 
 \section{Termopara}
 Zdecydowałem się na układ MAX6675, który jest jednym z najlepiej przetestowanych i najtańszych rozwiązań, ze względu na swoją długą obecność na rynku.
 
 \section{Układ poruszający przepustnicą} 
 Posiadany piec kominkowy potrzebuje przemieszczania liniowego przepustnicy, jednak odpowiednie serwomechanizmy są wciąż drogie i przewyższałyby swoją ceną koszt pozostałych podzespołów całego sterownika.
 Istnieje możliwość zaprojektowania i wydrukowania właściwego adaptera serwomechanizmu, lecz długi czas produkcji oraz testowania jego wytrzymałości przekraczałby zakres tej pracy.
  Ze względu na niewielką wymaganą precyzję ustawienia przepustnicy oraz zaistniałe opory, wybrałem standardowej wielkości, analogowy serwomechanizm MG-995, bez adapterów przekształcających ruch obrotowy na liniowy.
 
 \section{Moduł Ethernet}
 Zdecydowałem się na dołączenie dodatkowego modułu Ethernet, ponieważ sterownik bez przerwy komunikuje się z siecią w celu wymiany informacji. Wykorzystanie komunikacji WiFi generowałoby niepotrzebny smog elektromagnetyczny. Wybrany moduł W5500 Lite jest nieznacznie droższy, ale za to bardziej kompaktowy niż inne rozwiązania oparte o układ W5500.
 
 \section{Zegar czasu rzeczywistego}
 Pierwotnie planowałem wykorzystanie modułu czasu rzeczywistego z podtrzymaniem. Jednakże, sterownik przez większość czasu będzie podłączony do internetu, skąd może pozyskać aktualną godzinę, dlatego zrezygnowałem z tego rozwiązania.
 
 \section{Urządzenie wskazujące}
 Pierwszym planowanym rozwiązaniem było wykorzystanie przycisków typu pushbutton. Mikrokontroler ESP32 posiada jednak specjalne piny umożliwiające rozpoznawanie dotyku poprzez detekcję zmian pojemności, dlatego zdecydowałem się zastąpić pushbuttony panelem dotykowym.
 
 \section{Czujnik otwarcia drzwi paleniska}
 Czujnik otwarcia drzwi paleniska pozwala na wykrywanie momentów dokładania paliwa. W projekcie wykorzystałem prosty przełącznik podłączony do pinu cyfrowego mikrokontrolera.
 
 \section{Zasilanie awaryjne}
 Najprostszym z rozważanych rozwiązań było zastosowanie dodatkowego, zewnętrznego modułu typu powerbank. Jednak jego wykorzystanie nie dawałoby żadnej kontroli nad trybem zasilania sterownika, co mogłoby skutkować nagłym przerwaniem dostaw energii, a w konsekwencji możliwością przegrzania pieca. Wybrałem płytkę rozszerzeń typu battery shield z dwoma akumulatorami litowo-jonowymi 18650 o pojemności około 3600mAh każdy oraz układem ładowania i układem zabezpieczającym przed całkowitym rozładowaniem.
 
 \section{Źródło dźwięku}
 Jako źródło dźwięku w projekcie zdecydowałem się wykorzystać brzęczyk pasywny. W odróżnieniu od aktywnego, umożliwia on generowanie dźwięków o zmiennej częstotliwości za pomocą sygnału PWM. Dla ułatwienia konstrukcji zdecydowałem się wybrać moduł brzęczyka zawierający tranzystor sterujący, który chroni źródło sygnału przed przeciążeniem prądowym.
 
 \section{Rodzaj połączenia czujników zewnętrznych}
 Ze względu na łatwość i pewność połączenia zdecydowałem się na wybranie standardu złącza 8P8C, wykorzystywanego w rożnego rodzaju sprzęcie telekomunikacyjnym i komputerowym. Jest ono rozpowszechnione jako złącze do budowy sieci w standardzie Ethernet. 8P8C to złącze o ośmiu miejscach na styk i ośmiu stykach.
 
 
 \chapter{Wykonanie prototypu sterownika pieca kominkowego na płytce stykowej}
 W tym rozdziale opisany został proces prototypowania z wykorzystaniem płytki stykowej.
 Pozwala ona na łatwe połączenie elementów tworzonego układu. Podzespoły wpinane są w płytkę, a następnie łączone elektrycznie przy pomocy specjalnych przewodów.
 Pierwszym elementem sterownika umieszczonym na płytce był mikrokontroler ESP32. Nie wymagał on dodatkowych połączeń, ponieważ może być zasilany przez port USB.
  
 \section{Połączenie mikrokontrolera oraz LCD}
 Użyty w projekcie wyświetlacz LCD 16x2 posiada dodatkowo konwerter I2C, który zmniejsza ilość linii niezbędnych do komunikacji z 16 do 4. Wykorzystana do komunikacji magistrala I2C jest szeregowa oraz dwukierunkowa. Wykorzystuje tylko dwie linie komunikacyjne - Serial Data i Serial Clock. Transfer danych może być zainicjowany tylko, gdy magistrala nie jest zajęta. Poza liniami transferu danych wyświetlacz potrzebuje także pary linii zasilania - masy oraz 5V.
  
 \section{Podłączenie układu DHT22 - termometr i czujnik wilgotności}\label{dht}
 Do komunikacji z mikrokontrolerem moduł termometru i czujnika wilgotności DHT22  używa magistrali 1-Wire, która wykorzystuje pojedynczą linię komunikacyjną. W zależności od długości przewodów należy wybrać właściwy rezystor podciągający.  Mikrokontroler ESP32 posiada wbudowany opornik podciągający o wartości około 50k Ohmów. Jeśli przewody przyłączeniowe nie są długie, wtedy nie ma potrzeby wykorzystywania dodatkowego rezystora.
 Moduł termometru DHT22 potrzebuje również zasilania 3,3V.
 
 \section{Podłączenie termometru Dallas}
 Układ termometru Dallas DS18B20, do komunikacji z mikrokontrolerem, wykorzystuje magistrale 1-Wire opisaną w części \ref{dht}. Dodatkowo potrzebuje zasilania 3,3V.
 
 \section{Podłączenie układu MAX6675 - termopara}
 Układ MAX6675 wykorzystuje do komunikacji magistralę SPI - 3 linie komunikacyjne: SO - Master Input Slave Output, CS - Chip Select, SCK - Serial Clock. Do zasilania potrzebne jest napięcie 3,3V.
 
 \section{Podłączenie serwomechanizmu}
 Do podłączenia serwomechanizmu wystarczy jedna linia komunikacyjna przesyłająca sygnał PWM oraz zasilanie 5V.
 
 \section{Podłączenie czujnika otwarcia paleniska}
 Czujnik otwarcia drzwi paleniska w postaci prostego przełącznika został podłączony do pinu cyfrowego mikrokontrolera pojedynczą linią komunikacyjną. Linia ta będzie ustawiana w stan wysoki przy pomocy rezystora podciągającego. Otwarcie drzwi spowoduje zwarcie linii do masy. 
 
  \section{Podłączenie układu W5500 - Ethernet}
 Moduł W5500 wykorzystuje do komunikacji magistralę SPI - 4 linie komunikacyjne: MO - Master Output Slave Input, SO - Master Input Slave Output ,CS - Chip Select, SCK - Serial Clock.
 Podczas podłączania układu napotkano problemy z komunikacją. Konieczna była zmiana wykorzystywanych pinów mikrokontrolera.
 
 \section{Podłączenie brzęczyka}
 Do podłączenia brzęczyka potrzebna jest jedna linia komunikacyjna przesyłająca sygnał PWM oraz zasilanie 5V. Podczas podłączania napotkano problemy z komunikacją. Przyczyną okazało się błędne nazewnictwo pinów. Pin 32 został zamieniony z pinem 33 w opisie wyprowadzeń na płytce.
 
 
 \section{Wykonanie okablowania}
 Podłączenie zewnętrznych czujników do sterownika wykonano z wykorzystaniem skrętki ekranowanej która zapewnia odporność komunikacji na zakłócenia transmisji.
 
 
 \chapter{Opracowanie oprogramowania - część pierwsza}
 W tym rozdziale opisano proces pisania pierwszej części oprogramowania stanowiącej podstawę komunikacji z modułami sterownika. Dalsza część procesu programowania została opisana w rozdziale \ref{prog:2}.
 
 \section{Utworzenie projektu}
 Do programowania sterownika wykorzystano środowisko programistyczne CLion wraz z ekosystem PlatformIO.
 CLion to wieloplatformowe zintegrowane środowisko programistyczne (IDE) przeznaczone dla języków C/C++.
 PlatformIO Core jest sercem całego ekosystemu PlatformIO ułatwiającego programowanie mikrokontrolerów. Dostarcza interfejs wiersza poleceń. Jest napisane w Pythonie.
 Projekt oprogramowania sterownika został zainicjalizowany w pustym katalogu poleceniem:
 \begin{lstlisting}
platformio init --ide clion --board esp32doit-devkit-v1 
 \end{lstlisting}
 Definiuje ono z jakiego IDE chcemy skorzystać, oraz jaki mikrokontroler będzie programowany.
 Następnie projekt został otwarty w CLion, gdzie przebiega dalszy proces programowania.
 
 \section{Konfiguracja Projektu}
 W celu konfigurowania projektu należy poddać edycji plik platformio.ini. Daje on przede wszystkim możliwość wybrania frameworka, dodatkowych bibliotek, prędkości komunikacji z mikrokontrolerem przez monitor portu szeregowego oraz parametrów wgrywania oprogramowania.
 
 \section{Szkielet do budowy aplikacji}
 Spośród dwóch dostępnych dla mikrokontrolera ESP32 frameworków ze względu na dużą ilość gotowych bibliotek do komunikacji z modułami zdecydowano się na wykorzystanie platformy programistycznej Arduino.
 Program napisany dla tej platformy musi posiadać plik main w którym są dwie funkcje: setup oraz loop.
 Setup wykonywany jest tylko raz po uruchomieniu mikrokontrolera, natomiast loop wykonuje się w nieskończonej pętli aż do momentu zakończenia pracy.
 
 \section{Dodanie bibliotek i podstawowa komunikacja z urządzeniami}
 Aby sprawdzić poprawność działania prototypu wykonanego na płytce stykowej pisanie oprogramowania rozpoczęto od dodania bibliotek pozwalających na komunikację z urządzeniami. Dla każdego urządzenia stworzono osobny plik .h zawierający deklaracje funkcji oraz plik .cpp zawierający ich definicje.
 W dalszej kolejności zostało opisane użycie poszczególnych bibliotek.
  \subsection{Dodanie portalu przechwytującego}
 W pierwszej kolejności aby umożliwić łatwą konfigurację połączenia Wi-Fi w sterowniku wykorzystano bibliotekę ESP Acync WiFiManager \cite{WiFiManager} która pozwala na automatyczne tworzenie sieci WiFi i portalu przechwytującego dającego możliwość wybrania i połączenia się z docelową siecią WiFi zapewniającą łączność sterownika z Internetem. 
 Dla utworzenia  WiFi Menagera należy konstruktorowi przekazać dwa obiekty: serwer web oraz server dns. Następnie należy dodać funkcję zwrotną (callback) wykonywaną w momencie utworzenia przez WiFi Manger acces pointa. Aby uruchomić Menager należy wywołać metodę autoConnect przekazując jej jako opcjonalne parametry nazwę acces pointa oraz hasło. Po uruchomieniu Menager próbuje się połączyć z poprzednio zapamiętaną siecią WiFi. Jeśli jej nie odnajdzie, tworzy acces point oraz portal przechwytujący w którym można wybrać inną sieć. Po poprawnym połączeniu na port szeregowy wypisywany jest adres ip sterownika.
 \subsection{Dodanie biblioteki dla DHT22}
 Do komunikacji z czujnikiem temperatury i wilgotności wykorzystano bibliotekę DHT sensor library for ESPx \cite{DHTlibrary}. Aby zainicjować działanie biblioteki należy skorzystać z metody setup podając jako parametry numer pinu do którego podłączony jest czujnik oraz model czujnika. Do odczytania pomiarów służą metody getTemperature oraz getHumididity.
 \subsection{Dodanie biblioteki dla MAX6675}
 Do komunikacji z termoparą wykorzystano bibliotekę MAX6675 library \cite{MAX6675library}. Aby zainicjować bibliotekę należy skorzystać z konstruktora przekazując jako parametry numery pinów do komunikacji magistralą SPI.
 W celu odczytania temperatury należy skorzystać z metody readCelsius.
 \subsection{Dodanie biblioteki dla LCD}
 Do komunikacji z wyświetlaczem LCD z wykorzystaniem magistrali I2C wykorzystano bibliotekę LiquidCrystal PCF8574 \cite{LCDlibrary}. Aby zainicjować bibliotekę należy skorzystać z konstruktora przekazując jako parametr adres wyświetlacza na magistrali. Aby włączyć podświetlenie wyświetlacza należy skorzystać z metody setBacklight. Do wypisywania tekstu na wyświetlaczu służą metody print oraz println.
 \subsection{Dodanie biblioteki dla serwomechanizmu}
 Do komunikacji z serwomechanizmem wykorzystano bibliotekę ESP32Servo \cite{Servolibrary}. Aby rozpocząć pracę należy skorzystać z metody attach podając jako argument numer pinu będącego wyjściem sygnałowym. W celu ustawienia mechanizmu na wybraną pozycję należy skorzystać z metody write. Metoda detach służy do przerwania komunikacji z serwomechanizmem.
 \subsection{Dodanie biblioteki dla PID}
 Do sterowania wychyleniem serwa wykorzystano bibliotekę PID \cite{PIDlibrary}. Pozwala ona na wykorzystanie regulatora proporcjonalno-całkująco-różniczkującego do utrzymywania wartości wyjściowej na zadanym poziomie.
 Aby zainicjować bibliotekę  należy skorzystać z konstruktora przekazując jako parametr referencje do wartości wejściowej, wyjściowej, zadanej oraz trzy parametry regulatora. Przy pomocy funkcji SetSampleTime należy ustalić jak często regulator ma obliczać wartość wyjściową. Funkcja SetOutputLimits służy do określenia granic parametru wyjściowego, funkcja SetControlDirection służy do określenia kierunku sprzężenia wejścia z wyjściem, funkcja SetMode(AUTOMATIC) uruchamia działanie regulatora.
 \subsection{Dodanie biblioteki dla DS18B20}
 Do komunikacji z termometrem Dallas wykorzystano bibliotekę DallasTemperature \cite{dallaslibrary}. Aby zainicjować bibliotekę należy skorzystać z konstruktora przekazując jako parametr referencję do obiektu oneWire. W celu odczytania temperatury nalezy skorzystać z metody requestTemperatures, a następnie getTempCByIndex.
 \subsection{Dodanie biblioteki dla W5500}
 Do komunikacji z modułem W5500 wykorzystano bibliotekę Ethernet Library for Arduino \cite{ethernetlibrary}. Aby zainicjować bibliotekę należy użyć metody init podając jako parametr numer pinu Chip Select. Następnie należy skorzystać z metody WizReset wykonującej sekwencję resetowania modułu. W celu rozpoczęcia połączenia Ethernetowego należy użyć metody begin podając jako parametry adres MAC, adres IP, adres DNS, adres bramy oraz maskę.
 \subsection{Dodanie biblioteki WebThings}
 Do przekształcenia sterownika w rzecz webową wykorzystano bibliotekę webthing-arduino \cite{webthinglibrary}. Biblioteka tworzy prosty serwer implementujący Web of Things API.
 Aby zainicjować bibliotekę należy skorzystać z konstruktora przekazując jako parametry nazwę oraz adres IP. Następnie należy utworzyć instancję urządzenia oraz dodać do urządzenia jego właściwości. Aby rozpocząć pracę serwera należy skorzystać z metody begin. Do przekazywania wartości właściwości urządzenia służą metody setValue oraz update.
 
 \section{Dodanie zdalnego uaktualniania oprogramowania}
 Mechanizm Over The Air Update pozwala na wgrywanie nowych wersji oprogramowania przez sieć LAN lub Internet (jeśli urządzenie posiada publiczny adres IP). W celu uruchomieniu OTA należy w pliku konfiguracyjnym jako protokół wgrywania wybrać espota, a następnie podać adres urządzenia. Dodatkowo dla zabezpieczenie przed nieuprawnioną zmianą oprogramowania należy ustawić hasło blokujące dostęp.
 
 \section{Dodanie odczytu napięć}
 Mikrokontroler ESP32 posiada dwa 12 bitowe przetworniki ADC z których drugi nie może być używany gdy wykorzystywane jest WiFi. Domyślna rozdzielczość, 12 bitów (0 – 4095), może być zmniejszona do 9 (0 – 511).
 Aby odczytać wartości napięć pinów mikrokontrolera w pierwszej kolejności należy przy pomocy metody pinMode określić numer pinu oraz tryb pracy (INPUT), a następnie skorzystać z metody analogRead.
 
 \section{Dodanie wykrywania dotyku}
 Mikrokontroler ESP32 posiada wbudowane 10 pojemnościowych sensorów dotyku ale wykorzystana w projekcie płytka deweloperska ma wyprowadzone ich tylko 9. Odczyt sensorów dotyku jest bardzo prosty, wystarczy użyć funkcji touchRead jako argument podając numer pinu.
 
 \section{Dodanie obsługi brzęczyka}
 Do wytwarzania dźwięku brzęczyk potrzebuje sygnału PWM. Do generowania sygnału PWM przez mikrokontroler wykorzystano moduł LED Control z frameworka. W pierwszej kolejności należy skorzystać z funkcji ledcSetup podając trzy argumenty: kanał, częstotliwość oraz rozdzielczość. Następnie aby rozpocząć generowanie należ skorzystać z funkcji ledcAttachPin podając dwa argumenty: numer pinu do którego podłączone jest wejście sygnałowe brzęczyka oraz kanał.
 Aby zaprzestać generowania należy skorzystać z funkcji ledcWrite podając dwa argumenty: kanał oraz 0 (cykl pracy).
 
 \section{Testowanie sterownika}
 Po każdym etapie dodawania kolejnych modułów projektu działanie sterownika było testowane z wykorzystaniem monitora portu szeregowego poprzez odczytanie mierzonych przez sterownik wartości.

 
 \chapter{Wykonanie prototypu sterownika pieca kominkowego na płytce uniwersalnej}
 W tym rozdziale opisano przeniesienie prototypu z płytki stykowej na płytkę uniwersalną.
 Wykorzystanie płytki uniwersalnej pozwala na pewniejsze połączenie podzespołów układu jednocześnie pozostawiając wciąż pewną elastyczność do zmian w projekcie w ten sposób umożliwiając dalsze doskonalenie.
 
 \section{Rozmieszczenie elementów}
 Dla wygodnego połączenia elementów wybrano płytkę uniwersalną o rozmiarach 9cm x 15cm ze standardowym rastrem otworów 2,54mm.
 Na początku na płytce zostały umieszczone gniazda pod największe elementy: moduł zasilania o wymiarach 9,8cm x 2,9cm oraz mikrokontroler o wymiarach 5,5cm x 2,8cm. Gniazda pod kolejne elementy rozmieszczano tak aby porty komunikacyjne oraz zasilania znajdowały się na dwóch krawędziach płytki. 
 Największą trudność sprawiło umieszczenie na płytce portów sieciowych, gdyż wyprowadzenie ich połączeń sygnałowych nie jest zgodne z rastrem 2,54mm, a dodatkowo potrzebne są otwory montażowe.
  
  \section{Wykonanie panelu dotykowego}
 Panel dotykowy został wykonany z blaszek miedzianych o wymiarach 2cm x 2cm, przyklejonych do pokrywy sterownika, przylutowanych do przewodów zakończonych gniazdami. Podczas wycinania elementów należało zachować szczególną staranność dla zapewniania estetyki wykonania.

 \section{Połączenie elementów}
 Gniazda oraz goldpiny wszystkich elementów zostały połączone jednożyłowymi przewodami miedzianymi w izolacji. Przewody zostały rozmieszczone tak aby łatwo można było prześledzić drogę połączenia, a następnie przylutowane do płytki uniwersalnej. Różne kolory izolacji przewodów ułatwiają identyfikację połączeń. Zasilanie do złączy RJ-45 zostało doprowadzone tak aby oba przewody znajdowały się w jednej parze skrętki, co pozwala na zmniejszenie ilości generowanych zakłóceń.
 Sprawdzenia poprawności połączeń dokonano przy pomocy miernika uniwersalnego.

 \section{Zmiany w projekcie}
 Na etapie wykonywania prototypu na płytce uniwersalnej postanowiono wprowadzić kilka zmian do projektu sterownika.
 \subsection{Dodanie dzielnika napięcia}
 W celu wyrywania aktualnego źródła zasilania sterownika zdecydowano o pomiarze napięcia zasilania diod sygnalizacyjnych w układzie modułu zasilania awaryjnego. Aby dostosować napięcia do zakresu bezpiecznego dla mikrokontrolera zastosowano dzielniki napięcia składające się z rezystorów 1k Ohm.
 \subsection{Dodanie głównego włącznika zasilania}
 Dla umożliwienia łatwiejszego włączania zasilania zdecydowano się umieścić w projekcie dodatkowy przełącznik zasilania podłączony do modułu zasilania awaryjnego. Do małego przełącznika znajdującego się w module zasilania przylutowano dwa goldpiny. Duży przełącznik został podłączony do przewodów zakończonych gniazdami szpilkowymi pasującymi do goldpinów.

 \section{Testowanie prototypu}
 Po podłączeniu wszystkich elementów sterownika do płytki uniwersalnej sprawdzono działanie z wykorzystaniem monitora portu szeregowego.
 
 \chapter{Wykonanie obudowy}
 Pierwotnie rozważano możliwość wydruku obudowy na drukarce 3D \cite{Frence2014} jednak wielkość potrzebnej obudowy oraz czas niezbędny do wykonania projektu obudowy przesądziły o wykorzystaniu gotowej skrzynki z plastiku z przeźroczystym wieczkiem o rozmiarze 15,8cm x 9cm x 6cm pozwalającym na swobodne zmieszczenie wszystkich komponentów sterownika. Płytka uniwersalna została przycięta na rogach ponieważ skrzynka posada tam miejsca na śruby. W skrzynce wykonano w sumie 5 otworów. Jeden na górnej powierzchni obudowy, na port micro USB, przeznaczony na wypadek potrzeby bezpośredniego podłączenia do mikrokontrolera. Jeden na prawym brzegu obudowy, na port micro USB, przeznaczony do zasilania podczas normalnej pracy. Trzy otwory na dolnej powierzchni obudowy. Z lewej strony otwór na gniazdo 8p8c (często błędnie nazywane RJ-45) przeznaczone do połączenia z internetem. W środkowej części potrójne gniazdo 8p8c przeznaczone do komunikacji z czujnikami zewnętrznymi oraz serwomechanizmem. Z prawej strony otwór na główny włącznik.
 Po wykonaniu otworów i zamontowaniu komponentów sterownika przystąpiono do montowania panelu dotykowego. Poszczególne pola panelu zostały przyklejone do przezroczystego wieczka obudowy na kształt "+", każdy w odległości około 4mm od drugiego, co pozwala na minimalizację zakłóceń.
 Ostatnim etapem wykonania obudowy było wklejenie ekranu lcd w lewym górnym rogu przeźroczystego wieczka sterownika.
 Po umieszczeniu w obudowie i podłączeniu wszystkich elementów sterownika sprawdzono działanie z wykorzystaniem monitora portu szeregowego.
 
 \chapter{Opracowaniu oprogramowania - część druga}\label{prog:2}
 W tym rozdziale opisano dalszą część tworzenia oprogramowania sterownika. 

  \section{Rozbudowa portalu przechwytującego}
  W portalu przechwytującym zaprogramowano funkcję, wywoływaną w pętli głównej, podejmującą próbę połączenia z zapamiętaną siecią WiFi w przypadku utraty łączności.
  
 \section{Rozbudowa obsługi DHT22}
 Ponieważ jako punkt odniesienia dla sterownika postanowiono wykorzystać indeks cieplny zamiast temperatury w pliku dht stworzono funkcję pozwalającą na przekazanie indeksu do zmiennej. Dla zabezpieczenia poprawnej pracy sterownika funkcja ta zwraca informację o błędzie w przypadku niepowodzenia lub wątpliwych wartości temperatury i wilgotności na podstawie których obliczany jest indeks cieplny. 

 \section{Rozbudowa obsługi MAX6675}
 Dla zabezpieczenia poprawnej pracy sterownika jeśli odczyt temperatury się nie powiedzie, odczytane wartości są nierzeczywiste lub temperatura różni się znacznie od poprzedniego odczytu funkcja zwraca wartość 999 oraz wypisuje komunikat o błędzie. Zwrócenie przez funkcję tak wysokiej temperatury spowoduje szybkie zamknięcie przepustnicy przez regulator PID co będzie chroniło piec przed przegrzaniem.
 
 \section{Rozbudowa obsługi wyświetlacza LCD}
 Z obsługi LCD usunięto funkcję testową. Dodana została funkcja wyświetlająca podstawowe nastawy sterownika: zadaną temperaturę w kominie, aktualną temperaturę w kominie, zadany indeks cieplny w pomieszczeniu, aktualny indeks cieplny w pomieszczeni oraz procentowe otwarcie przepustnicy. Dodana została funkcja pozwalająca na włączanie podświetlenia LCD i wyłączanie go po zadanym czasie.

 \section{Rozbudowa obsługi serwomechanizmu}
 Obsługę serwomechanizmu uzupełniono o wyłączanie sygnału sterującego po zmianie pozycji co w znaczącym stopniu przyczyniło się do poprawy kultury pracy. Często występującym problemem było blokowanie się przepustnicy, ze względu na duże opory, przy nieznacznej zmianie wychylenia. Po wyłączeniu sygnału PWM serwomechanizm przestaje próbować ustawić zadawaną pozycję i zostaje w tej którą osiągnął wcześniej. Zapobiega to niepotrzebnemu poborowi energii oraz redukuje głośny dźwięk wydawany przez urządzenie.

 \section{Rozbudowa obsługi regulatora PID}
 W celu poprawy komfortu termicznego w pomieszczeniu zostały wykorzystane dwa regulatory PID. Pierwszy z nich na podstawie aktualnej temperatury w pomieszczeniu i zadanej temperatury oblicza zadaną temperaturę dla spalin w kominie. Drugi na podstawie aktualnych odczytów temperatury z komina i temperatury zadanej przez pierwszy z regulatorów oblicza wychylenie serwomechanizmu, a co za tym idzie stopień otwarcia przepustnicy powietrza dolotowego do komory spalania.
 Dla większej odporności na błędy dodano funkcje sprawdzające poprawność wartości wejściowych oraz obliczonych przez regulatory. Dodatkowo stworzono funkcję wypisującą powyższe wartości na port szeregowy.

 \section{Rozbudowa obsługi termometru Dallas DS18B20}
 Obsługę termometru Dallas uzupełniono o sprawdzanie odczytywanej wartości oraz informowanie o błędnym odczycie.

 \section{Rozbudowa obsługi modułu Ethernet W5500}
 Wbrew wcześniejszym założeniom nie udało się w przyjętym czasie przenieść komunikacji z radiowej na kablową. Obsługa modułu Ethernet W5500 została tylko poszerzona o funkcje z biblioteki sprawdzające rodzaj wykrytego urządzenia oraz status połączenia kablowego.
 
 \section{Rozbudowa obsługi odczytu napięć}
 Obsługę odczytu napięć uzupełniono o funkcję rozpoznającą źródło zasilania na podstawie dobranych doświadczalnie wartości progowych oraz cyklicznie przekazującą wyniki do części programu obsługującej WebThing.
 
 \section{Rozbudowa obsługi wykrywania dotyku}
 Rozpoznawanie dotyku uzupełniono o automatyczne dobieranie wartości progowych podczas uruchamiania sterownika. Dodano funkcję włączającą wyświetlacz LCD po wykryciu dotyku. Ponad to dodano funkcję cyklicznie wysyłającą odczytane przez detekcję dotyku wartości do części programu obsługującej Web Thing.
 
 \section{Rozbudowa obsługi brzęczyka}
 Do obsługi brzęczyka dodano funkcję włączającą oraz wyłączającą alarm.
 
 \section{Rozbudowa obsługi WebThings}
 Do serwera WebThings dodano w sumie 6 różnych urządzeń dla których określono właściwości zgodne z  WoT Capability Schemas \cite{wotschemas2020}:
 \begin{enumerate}
 \item[•] Sensor DHT22 posiada dwie własności: temperaturę (TemperatureProperty) i wilgotność (LevelProperty).
 \item[•] Sensor termopary posiada własność temperatury (TemperatureProperty).
 \item[•] Sensor PID posiada 6 własności: stopień otwarcia przepustnicy pieca (LevelProperty), temperaturę pomieszczenia (TemperatureProperty), zadaną temperaturę pomieszczenia (TargetTemperatureProperty), własność grzanie/chłodzenie (HeatingCoolingProperty), temperaturę w kominie (TemperatureProperty) oraz zadaną temperaturę w kominie (TemperatureProperty).
 \item[•] Sensor Dallas posiada jedną własność: temperaturę (TemperatureProperty).
 \item[•] Sensor dotyku posiada 5 własności (OnOffSwitch), po jednej dla każdego pola sensora.
 \item[•] Sensor zasilania posiada dwie własności (OnOffSwitch): zasilanie zewnętrzne oraz bateria pełna.
 \end{enumerate}
 Po określeniu właściwości dodatkowo należało przypisać każdej z nich odpowiednie atrybuty takie jak: tytuł, wielokrotność, jednostkę, tryb odczytu.
 Na końcu do każdego z sensorów dodana została funkcja uaktualniająca wartości w serwerze.
 \subsection{Napotkane problemy}
 Pierwszym ze znalezionych problemów było zwracanie niepełnego opisu rzeczy webowej w formacie JSON przez serwer WebThings. Przyczyną było definiowanie przez bibliotekę webthing-arduino zbyt małego rozmiaru dokumentu JSON. Po zgłoszeniu problemu na stronie projektu został on naprawiony w najnowszej wersji biblioteki poprzez umożliwienie użytkownikom wyboru zwiększonego bufora lub definiowania własnego rozmiaru.
 Drugim z napotkanych problemów było uaktualnianie tylko jednej z własności sensora po wywołaniu funkcji update z biblioteki webthing-arduino. Poszukiwania rozwiązania przyniosły odpowiedź: przyczyną problemu jest błąd w dodatku WebThing do Bramy Mozilli. Tymczasowym rozwiązaniem pozwalającym na poprawne przekazywanie wartości do bramy jest wywoływanie funkcji update po zmianie każdej własności z osobna.

 \section{Testowanie sterownika}
 Po opracowaniu kolejnej części oprogramowania sprawdzono działanie sterownika z wykorzystaniem monitora portu szeregowego.

 
% \section{Logika aplikacji}
% \subsection{Czas rozpalania}
% \subsection{Sygnalizowanie potrzeby dołożenia paliwa}
% \subsection{Zmiana działania po dołożeniu paliwa}
% \subsection{Regulacja pracy wentylatora}
% \subsection{Zamykanie przepustnicy po wypaleniu paliwa}
 
% \section{Dostrajanie parametrów}
% Parametry sterownika zostały dostrojone podczas wykorzystywania sterownika do kontrolowania pracy pieca kominkowego.
 
 
% \chapter{Testowanie oprogramowania}
% Głównie testy manualne działającego sprzętu.
% Wykresy w Bramie pokażą możliwość ciągłej pracy.
% Testy jednostkowe logiki aplikacji, najlepiej TDD.
 %\section{Testy jednostkowe}
% Testy jednostkowe zostały wykonane z wykorzystaniem Platformio Unit Testing \cite{PIOUnitTesting}. Pozwala na wykonywanie testów na urządzeniu docelowym lub z użyciem platformy Native, wtedy testy są przeprowadzane tylko w środowisku programistycznym.


 \chapter{Zintegrowanie sterownika pieca kominkowego z Mozilla Gateway}
 W tym rozdziale opisany został proces integrowania sterownika pieca kominkowego z Bramą Mozilli.
 
 \section{Przygotowanie lokalnej Bramy WebThings}
  Projekt WebThings Gateway by Mozilla oferuje cztery możliwości instalacji: wykorzystanie obrazu dla Raspberry Pi, wykorzystanie obrazu Docker, instalacja pakietu na Arch Linux lub samodzielna budowa ze źródła. Wybrana została opcja wykorzystania gotowego obrazu dla Raspberry Pi.
  Po wgraniu obrazu i uruchomieniu urządzenia należy przejść do konfiguracji \cite{gatewaystarted2019}. Połączyć się do utworzonej sicie WiFi i w portalu przechwytującym wskazać połączenie z jakiego będziemy korzystać. Następnie należy wybrać subdomenę oraz utworzyć konto pierwszego użytkownika. W tym momencie brama jest gotowa do działania.

 \section{Dodanie rzeczy webowych do Bramy WebThings}
 Kolejnym etapem integracji jest dodanie stworzonych przez sterownik rzeczy webowych do Bramy. Po włączeniu sterownika i połączeniu go z tą samą siecią lokalną co Brama należy wybrać opcję dodawania urządzeń. Brama automatycznie wykrywa rzeczy webowe i proponuje dodanie poszczególnych sensorów. Większość opcji można pozostawić jako domyślne potwierdzając tylko dodawanie.
 
 \section{Wykorzystywanie interfejsu Bramy WebThings}
 Dzięki zapewnieniu przez Fundację Mozilli zdalnej usługi tunelowania istnieje możliwość zalogowania się do Bramy WebThings poprzez, wybrany na etapie przygotowania, adres subdomeny oraz login i hasło. Po zalogowaniu się widoczne są aktualne parametry pracy sterownika oraz jest możliwość zmiany zadanej w pomieszczeniu temperatury. W zakładce "Logs" w interfejsie Bramy WebThings jest możliwość dodawania wykresów czasowych poszczególnych własności sensorów sterownika. W zakładce "Rules" jest możliwość dodawania reguł, np.: informujących użytkownika o wzroście temperatury poprzez powiadomienia push.
 
 \section{Tłumaczenie interfejsu Bramy WebThings}
 Aby poprawić dostępność i wygodę stworzonego rozwiązania, dla osób nie znających języka angielskiego, postanowiono dokonać tłumaczenia interfejsu Bramy WebThings na język polski. Projekt Bramy WebThings umożliwia dodawanie tłumaczeń z wykorzystaniem systemu Fluent \cite{fluent2020} który zapewnia naturalne brzmienie przekładów. Przygotowane tłumaczenie zostało dodane do projektu Bramy WebThings jako pull request \cite{gatewaypl2019}. Po dokonaniu poprawek zostało zatwierdzone i będzie dostępne po opublikowaniu najnowszej wersji Bramy WebThings.

 \chapter{Przygotowanie instrukcji obsługi sterownika pieca kominkowego}
 Obserwacja - rzadka konieczność dostosowywania parametrów sterownika sprawia, że użytkownicy zapominają o tym jak konfigurować sterownik.
 
 
 \chapter{Efekt końcowy na tle koncepcji}
 Refleksja na temat tego jak wygląda to co zaplanowałem w stosunku do tego co udało się uzyskać.
 
 
 \chapter{Podsumowanie}
% \addcontentsline{toc}{chapter}{Podsumowanie}
 Wnioski, jaką drogę przeszliśmy. Rozdział po rozdziale opisujemy co było wyzwaniem.
 
 
 \chapter{Dalszy kierunek prac}
% \addcontentsline{toc}{chapter}{Kierunki dalszych prac}
 Jeśli zaczynałbym projekt z moją dzisiejszą wiedzą jak podszedłbym do problemu. Jak dalej rozwijałbym pracę, jakie dalsze tematy zostałyby podjęte. 


% \chapter*{Podsumowanie}

% Nasz wybór (patrz: s.~\pageref{sec:wybor}) miał istotne znaczenie.
% O tym, co było następnie, pisaliśmy w podrozdziale \ref{sec:nastepnie}.
% Konsekwencje\,\ldots

 
%  \nocite{*}
% \bibliography{library}
% \bibliographystyle{acm}
 
 \inputencoding{utf8}
 
 \addcontentsline{toc}{chapter}{Książki}
 \printbibliography[title={Książki},type=book]
 
 \addcontentsline{toc}{chapter}{Artykuły}
 \printbibliography[title={Artykuły},type=article]
 
 \addcontentsline{toc}{chapter}{Prace dyplomowe}
 \printbibliography[title={Prace dyplomowe}, type=thesis]
 
 \addcontentsline{toc}{chapter}{Materiały konferencyjne}
 \printbibliography[title={Materiały konferencyjne},type=inproceedings]
 
 \addcontentsline{toc}{chapter}{Pozostałe źródła}
 \printbibliography[title={Pozostałe źródła}, nottype=article, nottype=book, nottype=inproceedings, nottype=thesis]

 

 \end{document}

